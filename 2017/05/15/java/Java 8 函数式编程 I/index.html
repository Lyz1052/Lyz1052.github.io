<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>Java 8 函数式编程 I | Life and Code</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Lambda表达式 Lambda表达式的一些例子 123456789101112131415161718//入参为空Runnable noArguments = () -&amp;gt; System.out.println(&amp;quot;Hello World&amp;quot;); //只有一个参数，可以省略括号//编译器对event参数进行类型推断ActionListener oneArgument = ev">
<meta name="keywords" content="java8,lambda,函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 8 函数式编程 I">
<meta property="og:url" content="http://yoursite.com/2017/05/15/java/Java 8 函数式编程 I/index.html">
<meta property="og:site_name" content="Life and Code">
<meta property="og:description" content="Lambda表达式 Lambda表达式的一些例子 123456789101112131415161718//入参为空Runnable noArguments = () -&amp;gt; System.out.println(&amp;quot;Hello World&amp;quot;); //只有一个参数，可以省略括号//编译器对event参数进行类型推断ActionListener oneArgument = ev">
<meta property="og:updated_time" content="2017-11-18T15:57:00.910Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 8 函数式编程 I">
<meta name="twitter:description" content="Lambda表达式 Lambda表达式的一些例子 123456789101112131415161718//入参为空Runnable noArguments = () -&amp;gt; System.out.println(&amp;quot;Hello World&amp;quot;); //只有一个参数，可以省略括号//编译器对event参数进行类型推断ActionListener oneArgument = ev">
  
    <link rel="alternate" href="/atom.xml" title="Life and Code" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>

      
        
          
        

        
        
      <body class="three">

      
      <div id="container" class="container">
      

        <article id="post-java/Java 8 函数式编程 I" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
	  
		<a class="main-nav-link" href="/">首页</a>
	  
    
	  
		<a class="main-nav-link" href="/archives">归档</a>
	  
    
	  
		


	
		
	

	
		
	

	
		
	

	
		
	

	
		
	

	
		
	

	
		
	

	
		
	

	
		
	

	
		
	


<a class='main-nav-link' target='_self' href='/categories/dota2/' >dota2</a><a class='main-nav-link' target='_self' href='/categories/git/' >git</a><a class='main-nav-link' target='_self' href='/categories/english/' >english</a><a class='main-nav-link' target='_self' href='/categories/hexo/' >hexo</a><a class='main-nav-link' target='_self' href='/categories/java/' >java</a><a class='main-nav-link' target='_self' href='/categories/js/' >js</a><a class='main-nav-link' target='_self' href='/categories/playground/' >playground</a><a class='main-nav-link' target='_self' href='/categories/shell/' >shell</a><a class='main-nav-link' target='_self' href='/categories/web/' >web</a><a class='main-nav-link' target='_self' href='/categories/算法/' >算法</a>
	  
    
  </nav>
  
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 源"></a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java 8 函数式编程 I
    </h1>
  


      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul>
<li>Lambda表达式的一些例子 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//入参为空</div><div class="line">Runnable noArguments = () -&gt; System.out.println(&quot;Hello World&quot;); </div><div class="line"></div><div class="line">//只有一个参数，可以省略括号</div><div class="line">//编译器对event参数进行类型推断</div><div class="line">ActionListener oneArgument = event -&gt; System.out.println(&quot;button clicked&quot;); </div><div class="line"></div><div class="line">//包含代码块的Lambda函数表达式</div><div class="line">Runnable multiStatement = () -&gt; &#123; </div><div class="line">    System.out.print(&quot;Hello&quot;);</div><div class="line">    System.out.println(&quot; World&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//包含两个或两个以上入参的Lambda表达式</div><div class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</div><div class="line"></div><div class="line">//显示声明参数的类型</div><div class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Lambda表达式的注意点</p>
<ul>
<li>函数中使用外部变量必须是final或等价于final的（类似匿名内部类只能引用final类型的变量，因为其使用的仅仅是变量的值）</li>
</ul>
</li>
<li><p>函数接口</p>
<ul>
<li>一些预定义的函数接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Predicator&lt;T&gt; T -&gt; return boolean</div><div class="line">Consumer&lt;T&gt; T -&gt; return void</div><div class="line">Supplier&lt;T&gt;  void -&gt; return T</div><div class="line">Function&lt;T,R&gt; T -&gt; return R </div><div class="line">UnaryOperator&lt;T&gt; T -&gt; return T</div><div class="line">BinaryOperator&lt;T,T&gt; (T,T) -&gt; return T</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><ul>
<li>Stream的惰性求值（类似建造者模式，在build方法执行之前不创建对象）  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> Stream&lt;Artist&gt; stream = allArtists.stream()</div><div class="line">    .filter(artist -&gt; &#123;</div><div class="line">        System.out.println(artist.getName());</div><div class="line">        return artist.isFrom(&quot;London&quot;);</div><div class="line">&#125;);//no console output</div><div class="line"></div><div class="line">long count = stream.count();</div><div class="line">//John Lennon</div><div class="line">//Paul McCartney</div><div class="line">//George Harrison</div><div class="line">//Ringo Starr</div><div class="line">//PS：这里的count相当于一个即时求值操作</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Stream的即时求值</p>
<ul>
<li>collect(toList())<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import static java.util.stream.Collectors.toList;</div><div class="line">...</div><div class="line">List&lt;String&gt; list = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).collect(toList());</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Stream使用时注意点</p>
<ul>
<li>对于一个业务需求，尽量用一个Stream进行链式操作获取结果</li>
<li>避免无意义的中间变量</li>
<li>max方法可以指定自定义的Comparator</li>
</ul>
</li>
<li><p>Stream的reduce方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;I&gt; reduce(I identity,BiFunction&lt;I,? super T,I&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</div></pre></td></tr></table></figure>
<ul>
<li>其中，I是目标类，T是Stream的泛型，二元函数accumulator是累加器，combiner是连接器</li>
<li>accumulator 用于给定的目标类和当前元素之间的累加，结果是目标类</li>
<li>combiner 用于累加结果之间的组合，因为整个过程可能产生多个中间流</li>
</ul>
</li>
<li><p>使用reduce实现Map的一种方法（书中提供的方法是直接使用ArrayList作为目标类）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static &lt;I, O&gt; List&lt;O&gt; map(Stream&lt;I&gt; stream, Function&lt;I, O&gt; mapper) &#123;</div><div class="line">    return stream.reduce((Stream&lt;O&gt;)target,//identity</div><div class="line">            (a,b)-&gt;&#123;//accumulator</div><div class="line">            return Stream.concat(a,Stream.of(mapper.apply(b)));</div><div class="line">        &#125;,(a,b)-&gt;&#123;//combiner</div><div class="line">        return Stream.concat(a,b);</div><div class="line">    &#125;)</div><div class="line">    .collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>因为ArrayList的combiner并没有类似concat的预定义方法，个人认为使用流作为目标类要简单一点，用reduce实现filter时同理
</code></pre><h3 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h3><ul>
<li>类中重写方法的优先级要高于接口的默认方法（为了不破坏已有实现）</li>
<li>super关键字可用于指定实现接口中冲突的默认方法（所以java8中super不一定指向父类了）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MusicalCarriage</div><div class="line">implements Carriage, Jukebox &#123;</div><div class="line">    @Override</div><div class="line">    public String rock() &#123;</div><div class="line">        return Carriage.super.rock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="高级集合类和收集器"><a href="#高级集合类和收集器" class="headerlink" title="高级集合类和收集器"></a>高级集合类和收集器</h3><ul>
<li><p>方法引用：方法引用自动支持多个参数，前提是选对了正确的函数接口</p>
<ul>
<li>这句话需要这么理解，方法引用只是直接调用方法的一种简化形式，原本该是Supplier接口的还是Supplier，BiFunction等等同理</li>
</ul>
</li>
<li><p>元素顺序：流的顺序和出现顺序，即流来源的元素顺序有关</p>
<ul>
<li>forEach是并行的，而forEachOrdered是顺序的</li>
</ul>
</li>
<li><p>转换成其他集合(collect)：使用toList，toSet方法时，不需要显式指定集合类型。使用toCollection()</p>
</li>
<li><p>数据分类：</p>
<ul>
<li>取最大（小）值 maxBy(Comparator)，minBy(Comparator)</li>
<li>常用的运算生成集合 averagingInt(ToIntFunction)</li>
<li>划分集合 partitioningBy(Predicator)</li>
<li>分组 groupingBy(Function)</li>
</ul>
</li>
<li><p>Stream API相关的一些等价表达:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    This inspection reports stream API call chains which can be simplified. </div><div class="line">    It allows to avoid creating redundant temporary objects when traversing a collection.</div><div class="line">    The following call chains are replaced by this inspection:</div><div class="line">**/</div><div class="line"></div><div class="line">Collection.stream().forEach() → Collection.forEach()</div><div class="line">Collection.stream().forEachOrdered() → Collection.forEach()</div><div class="line">Arrays.asList().stream() → Arrays.stream() or Stream.of()</div><div class="line">Collections.singleton().stream() → Stream.of()</div><div class="line">Collections.singletonList().stream() → Stream.of()</div><div class="line">Collections.emptyList().stream() → Stream.empty()</div><div class="line">Collections.emptySet().stream() → Stream.empty()</div><div class="line">Stream.filter().findFirst().isPresent() → Stream.anyMatch()</div><div class="line">Stream.filter().findAny().isPresent() → Stream.anyMatch()</div><div class="line">Stream.collect(Collectors.counting()) → Stream.count()</div><div class="line">Stream.collect(Collectors.maxBy()) → Stream.max()</div><div class="line">Stream.collect(Collectors.minBy()) → Stream.min()</div><div class="line">Stream.collect(Collectors.mapping()) → Stream.map().collect()</div><div class="line">Stream.collect(Collectors.reducing()) → Stream.reduce() or Stream.map().reduce()</div><div class="line">Stream.collect(Collectors.summingInt()) → Stream.mapToInt().sum()</div><div class="line">Stream.collect(Collectors.summingLong()) → Stream.mapToLong().sum()</div><div class="line">Stream.collect(Collectors.summingDouble()) → Stream.mapToDouble().sum()</div><div class="line">!Stream.anyMatch() → Stream.noneMatch()</div><div class="line">!Stream.anyMatch(x -&gt; !(...)) → Stream.allMatch()</div><div class="line">!Stream.noneMatch() → Stream.anyMatch()</div><div class="line">Stream.noneMatch(x -&gt; !(...)) → Stream.allMatch()</div><div class="line">Stream.allMatch(x -&gt; !(...)) → Stream.noneMatch()</div><div class="line">!Stream.allMatch(x -&gt; !(...)) → Stream.anyMatch()</div><div class="line">Note that the replacements semantic may have minor difference in some cases. </div><div class="line"></div><div class="line">/**</div><div class="line">    For example, Collections.synchronizedList(...).stream().forEach() is not synchronized while Collections.synchronizedList(...).forEach() is synchronized. </div><div class="line">    Or collect(Collectors.maxBy()) would return an empty Optional if the resulting element is null while Stream.max() will throw NullPointerException in this case.</div><div class="line">**/</div></pre></td></tr></table></figure>
<p>  注意：</p>
<ul>
<li>1.使用简短的表达式，避免冗余表达</li>
<li>2.有的情况下，这些表达之间并不完全等价，例如Collections.synchronizedList(…).stream()的forEach方法并不是同步的，但Collections.synchronizedList(…).forEach()是同步的，stream.max(…)方法在处理空流时会抛出错误，但是stream.collect(maxBy(…))方法会返回一个Optional<t>.empty()对象</t></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">发布日期:</span>
          <a href="/2017/05/15/java/Java 8 函数式编程 I/" class="article-date">
  <time datetime="2017-05-14T16:00:00.000Z" itemprop="datePublished">2017-05-15</time>
</a>

        </li>
        
          <li>
            <span class="label">分类:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>


          </li>
        
        
          <li>
            <span class="label">标签:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java8/">java8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lambda/">lambda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2017/05/18/java/Java 8 函数式编程 II/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Java 8 函数式编程 II
        
      </div>
    </a>
  
  
    <a href="/2017/05/03/js/JavaScript typed Arrays/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">JavaScript typed Arrays</div>
    </a>
  
</nav>


  
</article>




          
        




    <footer id="footer" class="post-footer footer">
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>有时候输了比赛，总感觉队友不给力. <em>—— 徐志雷</em></p>


  </div>
</footer>

        

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>






<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->








      </div>
    </div>
  </body>
</html>
