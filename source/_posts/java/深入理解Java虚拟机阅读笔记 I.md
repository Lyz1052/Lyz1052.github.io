---
title: 深入理解Java虚拟机阅读笔记 I
date: 2017-06-02
tags: 
	- java
	- 虚拟机
	- 阅读笔记
categories: 
	- java
---
### Java内存区域与内存溢出异常

---

### 运行时数据区

- 运行时数据区：线程共享：Java堆，方法区，线程私有：Java虚拟机栈，本地方法栈，程序计数器
- 程序计数器：指向虚拟机字节码指令地址，对于本地方法，该值为空
- Java虚拟机栈：线程对应的帧栈是线程私有的，并且和线程的生命周期相同，每个方法执行时会创建一个栈帧，并压入帧栈
- 本地方法栈：为虚拟机使用的本地方法服务，不同的虚拟机有不同的实现方式
- Java堆（GC堆）：所有对象和数组的实例都分配在堆上（规定如此，但并不是绝对的），根据不同的垃圾回收方法或者创建对象过程中的安全性要求，Java堆可以分为不同的区域（新生代，老年代，或TLAB等等）
- 方法区：存储虚拟机加载的类的描述信息，静态变量，常量，即时编译器编译后的代码等，方法区的实现和具体虚拟机有关
- 运行时常量池：方法区的一部分，存储类在编译期和运行期生成的字面量和符号引用


### Tips

- 程序计数器的所在的内存区域，是唯一不会出现任何OutOfMemoryError的内存区域
- 在逻辑上Java堆必须连续，但是物理上可以不连续
- HotSpot虚拟机将方法区作为Java堆中的一部分（即永久代），方便统一内存管理，通过-XX:MaxPermSize控制上限
- JDK7的HotSpot虚拟机里，字符串常量池已经移出永久代了（并不是去掉永久代）

### HotSpot虚拟机中的对象

- 创建对象
    - 读取创建对象指令
    - 该指令对应类的符号引用是否在运行时常量池中，如果没有，先执行类加载操作
    - 分配内存，分配方式的方式根据Java对象在内存中的分布方式决定，而分布方式又根据虚拟机采用的垃圾回收机制来决定，如果虚拟机采用的是Mark-Sweep方式进行垃圾回收，需要使用一张表记录对象在内存中的位置，内存分布是分散的，此时使用“空闲列表”方法来分配对象内存，而如果垃圾回收过程中带有压缩（Compact）操作，内存分布是归整的，那么使用“指针碰撞”的方式分配对象内存
    - 设置对象中的一些必要的信息
    - 执行init方法
- 对象的内存布局：对象头，实例数据，对齐填充
- 对象的访问定位方式：
    - 句柄 在内存中的句柄池中，查找对象的句柄，句柄中保存对象的实例数据指针和类型数据指针，从而取得实例数据或类型数据
    - 直接访问 对象的实例数据和对象指针保存在一起
    - 使用句柄进行访问，移动对象时，句柄地址并不需要修改，只需要修改对象的实例数据指针，而使用直接访问时，如果需要移动对象在内存中的位置，需要修改对象引用。不过直接访问只需要通过一次寻址就可以找到对象的实例数据，在多数场景下可以节省开销
    - HotSpot虚拟机使用直接访问方式访问对象

### Tips
- 分配内存的过程需要保证安全性，一种操作是采用同步锁，另一种方式是使用TLAB(Thread Local Allocation Buffer)对每个线程中的对象单独分配
- HotSpot使用的[垃圾收集器](http://1028826685.iteye.com/blog/2352507)