---
title: 深入理解Java虚拟机阅读笔记 I
date: 2017-06-02
tags: 
	- java
	- 虚拟机
	- 阅读笔记
categories: 
	- java
---
### Java内存区域与内存溢出异常

---

### 运行时数据区

- 运行时数据区：线程共享：Java堆，方法区，线程私有：Java虚拟机栈，本地方法栈，程序计数器
- 程序计数器：指向虚拟机字节码指令地址，对于本地方法，该值为空
- Java虚拟机栈：线程对应的帧栈是线程私有的，并且和线程的生命周期相同，每个方法执行时会创建一个栈帧，并压入帧栈
- 本地方法栈：为虚拟机使用的本地方法服务，不同的虚拟机有不同的实现方式
- Java堆（GC堆）：所有对象和数组的实例都分配在堆上（规定如此，但并不是绝对的），根据不同的垃圾回收方法或者创建对象过程中的安全性要求，Java堆可以分为不同的区域（新生代，老年代，或TLAB等等）
- 方法区：存储虚拟机加载的类的描述信息，静态变量，常量，即时编译器编译后的代码等，方法区的实现和具体虚拟机有关
- 运行时常量池：方法区的一部分，存储类在编译期和运行期生成的字面量和符号引用


### Tips

- 程序计数器的所在的内存区域，是唯一不会出现任何OutOfMemoryError的内存区域
- 在逻辑上Java堆必须连续，但是物理上可以不连续
- HotSpot虚拟机将方法区作为Java堆中的一部分（即永久代），方便统一内存管理，通过-XX:MaxPermSize控制上限
- JDK7的HotSpot虚拟机里，字符串常量池已经移出永久代了（并不是去掉永久代）

### HotSpot虚拟机中的对象

- 创建对象
    - 读取创建对象指令
    - 该指令对应类的符号引用是否在运行时常量池中，如果没有，先执行类加载操作
    - 分配内存，分配方式的方式根据Java对象在内存中的分布方式决定，而分布方式又根据虚拟机采用的垃圾回收机制来决定，如果虚拟机采用的是Mark-Sweep方式进行垃圾回收，需要使用一张表记录对象在内存中的位置，内存分布是分散的，此时使用“空闲列表”方法来分配对象内存，而如果垃圾回收过程中带有压缩（Compact）操作，内存分布是归整的，那么使用“指针碰撞”的方式分配对象内存
    - 设置对象中的一些必要的信息
    - 执行init方法
- 对象的内存布局：对象头，实例数据，对齐填充
- 对象的访问定位方式：
    - 句柄 在内存中的句柄池中，查找对象的句柄，句柄中保存对象的实例数据指针和类型数据指针，从而取得实例数据或类型数据
    - 直接访问 对象的实例数据和对象指针保存在一起
    - 使用句柄进行访问，移动对象时，句柄地址并不需要修改，只需要修改对象的实例数据指针，而使用直接访问时，如果需要移动对象在内存中的位置，需要修改对象引用。不过直接访问只需要通过一次寻址就可以找到对象的实例数据，在多数场景下可以节省开销
    - HotSpot虚拟机使用直接访问方式访问对象

### Out Of Memory(OOM)异常

- Java堆OOM：-Xms和-Xmx分别控制Java堆的最小和最大内存大小
    ```
    ...
    while(true){
        list.add(new Object())
    }//...java.lang.OutOfMemoryError：Java heap space
    ...
    ```
    内存泄露时，需要找出哪些是GC无法回收的对象，并确定这些对象无法回收的原因，如果不存在内存泄露，那么需要从代码层面找出对象生命周期过长的原因，或者检查虚拟机的上述参数，对比物理内存看看是否可以增加

- 方法区和运行时常量池OOM
    - 运行时常量池中，字符串的存储位置在JDK7之后有变动，所以下列代码在不同的JDK下有不同表现
    ```
    String str1 = new StringBuilder().append("计算机软件).toString();
    System.out.println(str1==str1.intern());
    str1 = new StringBuilder().append("java").toString();
    System.out.println(str1==str1.intern());
    
    //jdk6 false false
    //jdk7 true false
    ```
    原因是在JDK7中，运行时常量池会存储第一次出现的字符串的**引用**，而之前的版本会把第一次出现的字符串直接复制到运行时常量池中
    - 方法区出现OOM时，一般是因为大量产生的动态类，或者大量的JSP文件（JSP文件第一次运行时，需要编译成JAVA类），因为类被回收的条件比较苛刻

- 本机直接内存溢出


### Tips
- 分配内存的过程需要保证安全性，一种操作是采用同步锁，另一种方式是使用TLAB(Thread Local Allocation Buffer)对每个线程中的对象单独分配
- HotSpot使用的[垃圾收集器](http://1028826685.iteye.com/blog/2352507)

### Java垃圾回收机制
---
### 引用计数
### 可达性分析