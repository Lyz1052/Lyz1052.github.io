---
title: 非递归生成全排列
date: 2017-06-01
tags: 
	- 算法
	- javascript
categories: 
	- 算法
---
### 思路
- 一般来说，数字的全排列问题类似与八皇后问题，用递归做起来比较方便，这里不去讨论使用递归的算法。

- 考虑到使用递归的回溯算法中，实际上是dps的尝试过程，把这个过程用普通循环来表达，就可以不使用递归算法

- 对于长度为n的有序自然数序列a(a0=1,a1=2,a2=3...)，首先，我们设定一个起点，当深度为0时，位置是a0，接下来开始循环遍历，从a1开始出发，我们定义一个 go 方法，从当前位置出发，每次使用a中的剩余的元素中最小的那一个（保持a的有序性），使用后将其去除，当走到最后一个位置（或者说a为空）时，我们得到了一个有效序列。我们再定义一个back方法，每向上返回一个位置，我们都把该位置上的数回填到a中（这里不能直接push，需要保持a的有序性），然后观察是否该位置的元素，在a中有更大的，如果有，那么从该位置开始，选择这个更大的元素，返回循环，如果没有，则返回上一个位置。最终，循环结束的条件是在深度为0的位置上，a中仍然没有比其更大的元素（或者说尝试返回深度为-1的位置）。

### Javascript代码
```
function permutation(n){
	var ans = [];
	var nused = Array(n).fill(0).map((e,i)=>{return i+1});//生成递增数列
	
	//init
	var depth=0,map=[];
	map[depth++]=nused.splice(0,1)[0];
	var c=0;debugger;
	do{
		if(c++>1000)break;
		go();
	}while(back())
	

	function insertSort(a,x){
		for(var i=0;i<n;i++){
			if(a[i]>=x){
				a.splice(i,0,x);
				return;
			}
		}
		a.push(x);
	}
	
	function go(){
		while(depth<n){
			map[depth++]=nused.splice(0,1)[0];
		}
		
		ans.push(stringifyArr(map));//map to string
	}
	
	function back(){
		while(depth--){
			insertSort(nused,map[depth]);
			
			var nextIndex = nused.indexOf(map[depth])+1;
			
			if(nextIndex>0&&nextIndex<nused.length){
				
				map[depth++]=nused.splice(nextIndex,1)[0];
				return true;
				
			}else{
				
				
				if(!depth)
					return false;
			}
		}
		return false;
	}
	
	function stringifyArr(a,split){
		split=split || "";
		return a.reduce(function(p,c){return p+split+c})
	}
	
	return stringifyArr(ans,",");
}

```

### 坑
- splice方法返回的是数组，数组，数组
- splice(index,count,ele...)方法的元素插入位置在index位置之前，之前，之前
- back方法中，先把当前值插入序列，再进行判断

### Tips
- insertSorted 方法实际上就是直接插入排序
- 如果不是写出所有全排列，而是计算全排列的总数，除了数学方法，貌似还没想到什么特别的非递归方法